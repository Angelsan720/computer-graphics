<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - template</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    canvas {
      border: dashed 1px black;
    }
    canvas:focus { /* Make clear when canvas does not listen to keyboard */
      border: solid 1px black;
    }
    kbd {
        font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
        font-size: 90%; background-color: #ddd;
        border: solid 1pt black; border-radius: 4px; padding: 0px 4px;
    }
  </style>
</head>
<script src="lib/three.min.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/controls/FlyControls.js"></script>
<script src="js/loaders/OBJLoader.js"></script>
<script src="lib/dat.gui.js"></script>
<script>
    var camera, scene, renderer
    var mainAxis
    var colors = {
                "BLACK":[   [ new THREE.Vector2( 3/4 , 1/2 ), new THREE.Vector2( 3/4 , 0 )  , new THREE.Vector2( 1, 1/2 )],
                            [ new THREE.Vector2( 3/4 , 1/2 ), new THREE.Vector2( 3/4 , 0 )  , new THREE.Vector2( 1, 1/2 )]],
                "RED":[     [ new THREE.Vector2( 0 , 0 )    , new THREE.Vector2( 1/4, 0)    , new THREE.Vector2( 1/4 , 1/2)],
                            [ new THREE.Vector2( 0 , 1/2)   , new THREE.Vector2( 0 , 0 )    , new THREE.Vector2( 1/4, 1/2)]],
                "WHITE":[   [ new THREE.Vector2( 1/2 , 1/2 ), new THREE.Vector2( 1/2 , 0 )  , new THREE.Vector2( 3/4 , 1/2 )],
                            [ new THREE.Vector2( 1/2 , 0   ), new THREE.Vector2( 3/4 , 0 )  , new THREE.Vector2( 3/4 , 1/2 )]],
                "YELLOW":[  [ new THREE.Vector2( 1/4 , 1/2) , new THREE.Vector2( 1/4 , 0 )  , new THREE.Vector2( 1/2, 1/2)],
                            [ new THREE.Vector2( 1/4 , 0 )  , new THREE.Vector2( 1/2, 0)    , new THREE.Vector2( 1/2 , 1/2)],],
                "BLUE":[    [ new THREE.Vector2( 0 , 1)     , new THREE.Vector2( 0 , 1/2 )  , new THREE.Vector2( 1/4, 1)],
                            [ new THREE.Vector2( 0 , 1/2 )  , new THREE.Vector2( 1/4, 1/2)  , new THREE.Vector2( 1/4 , 1)]],
                "GREEN":[   [ new THREE.Vector2( 1/4 , 1)   , new THREE.Vector2( 1/4 , 1/2 ), new THREE.Vector2( 1/2, 1)],
                            [ new THREE.Vector2( 1/4 , 1/2 ), new THREE.Vector2( 1/2, 1/2)  , new THREE.Vector2( 1/2 , 1)]],
                "PURPLE":[  [ new THREE.Vector2( 1/2 , 1)   , new THREE.Vector2( 1/2 , 1/2 ), new THREE.Vector2( 3/4, 1)],
                            [ new THREE.Vector2( 1/2 , 1/2 ), new THREE.Vector2( 3/4, 1/2)  , new THREE.Vector2( 3/4, 1)]]}
    var rotations = {
        "X":[3,1,2,0],
        "Y":[5,0,4,1],
        "Z":[4,2,5,3],
        "-X":[3,0,2,1],
        "-Y":[5,1,4,0],
        "-Z":[2,4,3,5]}
    var params = {
        showMainAxis:true,
        size:50,
        axis:[0,0,0],
        speed:5,
        forward:true,
        rotation:90 * Math.PI / 180,
        model:{},
            //  X+              X0          X-
        nodes:[ 1*2*3*5     ,   1*2*5   ,   1*2*5*7     ,//Y+   Z+
                1*2*3       ,   1*2     ,   1*2*7       ,//     Z0
                1*2*3*11    ,   1*2*11  ,   1*2*7*11    ,//     Z-

                1*3*5       ,   1*5     ,   1*5*7       ,//Y0
                1*3         ,   1       ,   1*7         ,
                1*3*11      ,   1*11    ,   1*7*11      ,

                1*3*5*13    ,   1*5*13  ,   1*5*7*13    ,//Y-
                1*3*13      ,   1*13    ,   1*7*13      ,
                1*3*11*13   ,   1*11*13 ,   1*7*11*13   ],
        perm:[]
            }

    /* ### GUI controls ### */
    var gui = undefined;
    function initGUI() {
        gui = new dat.GUI();//<--- BLACK MAGIC

        gui.add(params, 'forward').onChange(update)
        gui.add(params, 'showMainAxis').onChange(update)
        //gui.add(params, 'axis').onChange(update)

    }
    function updateGUI(theGui) {
        if (typeof(theGui)==="undefined") theGui=gui;

        // Update the GUI display based on current parameters
        // Source: http://stackoverflow.com/a/29069189
        for (var i in gui.__controllers) {
            theGui.__controllers[i].updateDisplay();
        }
        // Do recursion to update inside folders
        for (var f in gui.__folders) {
            updateGUI(theGui.__folders[f]);
        }
    }

    /* ### Keyboard ### */
    var currentlyPressedKeys = {};
    function initKeys(canvas) {
        // Make sure the canvas can receive the key events
        canvas.setAttribute('tabindex','0');
        canvas.focus();
        // Workaround: give the focus back to the canvas when clicked
        // keyboard events are not received when canvas is not focused
        canvas.addEventListener('mousedown',function(){canvas.focus()});

        // Register the keyDown and keyUp events
        canvas.addEventListener( "keydown", onKeyDown, true);
        canvas.addEventListener( "keyup",   onKeyUp, true);
    }
    // Callbacks for discrete key events
    function onKeyDown(event){
        // Uncomment this to display key presses to find the keyCodes
        //console.log(event)
        event.preventDefault();

        // Handle single key presses (for example for firing the gun)
        if (event.keyCode == 67) { // K
            console.log('Pressed key "K"')
        }
        if ("0,0,0"!=params.axis){
            //console.log("returning")
            return
        }
        if (event.key == "1") {
            params.work=[1*2*3*5,1*2*3,1*2*3*11,1*3*5,1*3,1*3*11,1*3*5*13,1*3*13,1*3*11*13]
            if (params.forward){
                params.perm = rotations["X"]
                params.axis=[1,0,0]
            }
            else{
                params.perm = rotations["-X"]
                params.axis=[-1,0,0]
            }
        }
        if (event.key == "2") {
            params.work=[1*2*5,1*2,1*2*11,1*5,1*11,1*5*13,1*13,1*11*13]
            if (params.forward){
                params.perm = rotations["X"]
                params.axis=[1,0,0]
            }
            else{
                params.perm = rotations["-X"]
                params.axis=[-1,0,0]
            }
        }
        if (event.key == "3") {
            params.work=[1*2*5*7,1*2*7,1*2*7*11,1*5*7,1*7,1*7*11,1*5*7*13,1*7*13,1*7*11*13]
            if (params.forward){
                params.perm = rotations["X"]
                params.axis=[1,0,0]
            }
            else{
                params.perm = rotations["-X"]
                params.axis=[-1,0,0]
            }
        }
        if (event.key == "4") {
            params.work=[1*2*3*5,1*2*5,1*2*5*7,1*2*3,1*2,1*2*7,1*2*3*11,1*2*11,1*2*7*11]
            if (params.forward){
                params.perm = rotations["Y"]
                params.axis=[0,1,0]
            }
            else{
                params.perm = rotations["-Y"]
                params.axis=[0,-1,0]
            }
        }
        if (event.key == "5") {
            params.work=[1*3*5,1*5,1*5*7,1*3,1*7,1*3*11,1*11,1*7*11]
            if (params.forward){
                params.perm = rotations["Y"]
                params.axis=[0,1,0]
            }
            else{
                params.perm = rotations["-Y"]
                params.axis=[0,-1,0]
            }
        }
        if (event.key == "6") {
            params.work=[1*3*5*13,1*5*13,1*5*7*13,1*3*13,1*13,1*7*13,1*3*11*13,1*11*13,1*7*11*13]
            if (params.forward){
                params.perm = rotations["Y"]
                params.axis=[0,1,0]
            }
            else{
                params.perm = rotations["-Y"]
                params.axis=[0,-1,0]
            }
        }
        if (event.key == "7") {
            if (params.forward){
                params.work=[1*2*3*11,1*2*11,1*2*7*11,1*3*11,1*11,1*7*11,1*3*11*13,1*11*13,1*7*11*13]
                params.perm = rotations["Z"]
                params.axis=[0,0,1]
            }
            else{
                params.perm = rotations["-Z"]
                params.axis=[0,0,-1]
            }
        }
        if (event.key == "8") {
            params.work=[1*2*3,1*2,1*2*7,1*3,1*7,1*3*13,1*13,1*7*13]
            if (params.forward){
                params.perm = rotations["Z"]
                params.axis=[0,0,1]
            }
            else{
                params.perm = rotations["-Z"]
                params.axis=[0,0,-1]
            }
        }
        if (event.key == "9") {
            params.work=[1*2*3*5,1*2*5,1*2*5*7,1*3*5,1*5,1*5*7,1*3*5*13,1*5*13,1*5*7*13]
            if (params.forward){
                params.perm = rotations["Z"]
                params.axis=[0,0,1]
            }
            else{
                params.perm = rotations["-Z"]
                params.axis=[0,0,-1]
            }
        }
        updateGUI() // Update dat.GUI display in case we changed params
        update()    // Update scene
    }
    function onKeyUp(event){}
    function degToRad(a){//THIS SHOULD BE PART OF  MATH
        return a/180*Math.PI;
    }
    //params.work=[]

    /* ### Main functions: init, update, animate, render... ### */
    function initScene(){
        // ##### 1. Create renderer and bind it to the canvas #####

        canvas = document.getElementById("canvas")
        renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        preserveDrawingBuffer: true});
        //document.body.appendChild(renderer.domElement)
        renderer.setClearColor(0xffffff)

        //renderer.setClearColor(0xffffff)


        // ##### 2. Create a scene and add objects to it #####

        scene = new THREE.Scene();

    	drawAxis(true)
        drawNodes()

        // ##### 3. Add lights to the scene #####
        var ambientLight = new THREE.AmbientLight(0x303030);
        scene.add(ambientLight)

        var pointLight = new THREE.PointLight(0xffffff)
        pointLight.position.set(150, 250, 125)
        scene.add(pointLight)

        // Add a sphere to be able to see where the point light is located
        // Not necessary for the light to work, can be disabled in the GUI
        pointLightGeo = new THREE.SphereGeometry(10, 8,4)
        pointLightMat = new THREE.MeshBasicMaterial({color:0xffffd0, wireframe:true})
        pointLightMesh = new THREE.Mesh(pointLightGeo, pointLightMat)
        pointLightMesh.position.copy(pointLight.position)
        scene.add(pointLightMesh)


        // ##### 4. Create camera #####

        camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 1, 2000);
        camera.position.set(100, 150, 150)
        camera.lookAt(new THREE.Vector3(0, 0, 0))


        // ##### 5. Add orbit controls #####
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.addEventListener('change', render); // add this only if there is no animation loop (requestAnimationFrame)
        controls.enableDamping = true;
        controls.dampingFactor = 0.10;
        controls.enableZoom = true;
        controls.enableKeys = false; // Disable keys so we can use them ourselves
        controls.rotateSpeed = 0.1;
    }
    function drawNodes(){
        var textureLoader = new THREE.TextureLoader()
        //var face = textureLoader.load("image/colorsN.png")
        var face = textureLoader.load("image/colors.png")
        for(var i = 0; i < params.nodes.length; i++){
            var geometry = new THREE.BoxGeometry( 1, 1, 1 )
            var material = new THREE.MeshBasicMaterial( {color: 0xffffff , map:face} )

            var mesh = new THREE.Mesh(geometry , material )
            /*
            mesh.geometry.faceVertexUvs[0][0]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][1]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][2]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][3]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][4]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][5]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][6]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][7]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][8]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][9]  = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][10] = colors["BLACK"]
            mesh.geometry.faceVertexUvs[0][11] = colors["BLACK"]*/

            if (params.nodes[i]%3==0){
                mesh.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(1,0,0))
            }
            if (params.nodes[i]%7==0){
                mesh.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(-1,0,0))
            }
            if (params.nodes[i]%2==0){
                mesh.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,1,0))
            }
            if (params.nodes[i]%13==0){
                mesh.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,-1,0))
            }
            if (params.nodes[i]%5==0){
                mesh.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,0,1))
            }
            if (params.nodes[i]%11==0){
                mesh.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,0,-1))
            }
            mesh.geometry.faceVertexUvs[0][1] = colors["RED"][0]
            mesh.geometry.faceVertexUvs[0][0] = colors["RED"][1]
            mesh.geometry.faceVertexUvs[0][2] = colors["YELLOW"][0]
            mesh.geometry.faceVertexUvs[0][3] = colors["YELLOW"][1]
            mesh.geometry.faceVertexUvs[0][4] = colors["WHITE"][0]
            mesh.geometry.faceVertexUvs[0][5] = colors["WHITE"][1]
            mesh.geometry.faceVertexUvs[0][6] = colors["BLUE"][0]
            mesh.geometry.faceVertexUvs[0][7] = colors["BLUE"][1]
            mesh.geometry.faceVertexUvs[0][8] = colors["GREEN"][0]
            mesh.geometry.faceVertexUvs[0][9] = colors["GREEN"][1]
            mesh.geometry.faceVertexUvs[0][10] = colors["PURPLE"][0]
            mesh.geometry.faceVertexUvs[0][11] = colors["PURPLE"][1]



            params.model[params.nodes[i]] = mesh
            params.model[params.nodes[i]].scale.set(params.size,params.size,params.size)
            scene.add(params.model[params.nodes[i]])
        }
    }
    function drawAxis(){
        mainAxis = new THREE.AxisHelper(100);
        mainAxis.material.linewidth = 5
        scene.add(mainAxis);
    }

    /*Rotation and mesh update*/
    function swap(list , a , b){
        for (var i = 0; i < 12; i++) {
            tmp = list[a*12+i]
            list[a*12+i] = list[b*12+i]
            list[b*12+i] = tmp
        }
        return list
    }
    function getUVs(target){
        l = []
        //console.log(target.faceVertexUvs)
        for(var i = 0 ; i < target.faceVertexUvs[0].length ; i++){
            for(var j = 0 ; j < 3 ; j++){
                l.push(target.faceVertexUvs[0][i][j].x)
                l.push(target.faceVertexUvs[0][i][j].y)
                console.log(i , j)
            }
        }
        return(l)
    }
    function permute(l){
        //console.log(l.length/params.perm.length)
        swap(l,params.perm[0],params.perm[1])
        swap(l,params.perm[0],params.perm[2])
        swap(l,params.perm[0],params.perm[3])

        return l
    }
    function setUVs(target , list){
        for(var i = 0 ; i < target.faceVertexUvs[0].length ; i++){
            for(var j = 0 ; j < 3 ; j++){
                x = list.pop()
                y = list.pop()
                target.faceVertexUvs[0][i][j].set(x , y)
            }
        }
    }
    function swapTexture(target){

        setUVs(target , permute(getUVs(target).reverse()))

        target.uvsNeedUpdate = true
        //console.log("update")

    }
    function resetRotation(){
        for(var i = 0; i < params.work.length; i++){
            swapTexture(params.model[params.work[i]].geometry)
            params.model[params.work[i]].rotation.set(0,0,0)
        }
        params.axis=[0,0,0]
        params.rotation=90 * Math.PI / 180

    }
    function rotate(){
        params.rotation = params.rotation-params.speed*elapsed
        for(var i = 0; i < params.work.length; i++){
            target = params.model[params.work[i]]
            target.rotateX(params.speed*elapsed*params.axis[0])
            target.rotateY(params.speed*elapsed*params.axis[1])
            target.rotateZ(params.speed*elapsed*params.axis[2])
        }
    }

    /* ### Timing and main loop ### */
    var startTime = 0;
    var lastTime = 0;
    var elapsed = 0, totalElapsed = 0;
    function updateTime() {
        var timeNow = new Date().getTime() / 1000; // All expressed in seconds
        if (lastTime != 0) {
            elapsed = timeNow - lastTime;
        } else {
            startTime = timeNow;
        }
        lastTime = timeNow;
        totalElapsed = timeNow - startTime;
    }
    function update(){
        // Helpers: plane and axes
        mainAxis.visible = params.showMainAxis;//show the main axis or not
        if ("0,0,0"!=params.axis){//DARK ART OF THE HIGHEST ORDER
            if (params.rotation>0){
                rotate()
            }
            else{
                resetRotation()
            }
        }
        render()
    }
    function animate(){
        updateTime()
        update()
        render()
        requestAnimationFrame(animate);
    }
    function render(){
        renderer.render(scene, camera);
    }
    function start(){
        initGUI()
        initScene()
        initKeys(canvas)

        update()
        render()
        //z3(true)
        // Uncomment animate() if there are automatic animations in your scene
        animate()
    }
</script>

<body onload='start();'>

  <div style="float: left;">
    <canvas id="canvas" width="500" height="500"></canvas>
    <br>3d Scene
    <br>Hold Left Mouse Button and drag to orbit around the scene.
    <br>Use arrow keys to move and rotate the robot using tank controls.
    <br>Use the gui on the right to:
    <br>articulate the robot arms in one axis
    <br>turn the plane on and off
    <br>turn the plane grid on and off
    <br>turn turn the main axis on and off
    <br>turn the objects axis on and off


  </div>

</body>

</html>
