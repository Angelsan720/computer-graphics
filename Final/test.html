<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - template</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    canvas {
      border: dashed 1px black;
    }
    canvas:focus { /* Make clear when canvas does not listen to keyboard */
      border: solid 1px black;
    }
    kbd {
        font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
        font-size: 90%; background-color: #ddd;
        border: solid 1pt black; border-radius: 4px; padding: 0px 4px;
    }
  </style>
</head>
<script src="lib/three.min.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/controls/FlyControls.js"></script>
<script src="js/loaders/OBJLoader.js"></script>
<script src="lib/dat.gui.js"></script>
<script>
    var camera, scene, renderer
    var mainAxis
    var colors = {
                "BLACK":[   [ new THREE.Vector2( 3/4 , 1/2 ), new THREE.Vector2( 3/4 , 0 )  , new THREE.Vector2( 1, 1/2 )],
                            [ new THREE.Vector2( 3/4 , 1/2 ), new THREE.Vector2( 3/4 , 0 )  , new THREE.Vector2( 1, 1/2 )]],
                "RED":[     [ new THREE.Vector2( 0 , 0 )    , new THREE.Vector2( 1/4, 0)    , new THREE.Vector2( 1/4 , 1/2)],
                            [ new THREE.Vector2( 0 , 1/2)   , new THREE.Vector2( 0 , 0 )    , new THREE.Vector2( 1/4, 1/2)]],
                "WHITE":[   [ new THREE.Vector2( 1/2 , 1/2 ), new THREE.Vector2( 1/2 , 0 )  , new THREE.Vector2( 3/4 , 1/2 )],
                            [ new THREE.Vector2( 1/2 , 0   ), new THREE.Vector2( 3/4 , 0 )  , new THREE.Vector2( 3/4 , 1/2 )]],
                "YELLOW":[  [ new THREE.Vector2( 1/4 , 1/2) , new THREE.Vector2( 1/4 , 0 )  , new THREE.Vector2( 1/2, 1/2)],
                            [ new THREE.Vector2( 1/4 , 0 )  , new THREE.Vector2( 1/2, 0)    , new THREE.Vector2( 1/2 , 1/2)],],
                "BLUE":[    [ new THREE.Vector2( 0 , 1)     , new THREE.Vector2( 0 , 1/2 )  , new THREE.Vector2( 1/4, 1)],
                            [ new THREE.Vector2( 0 , 1/2 )  , new THREE.Vector2( 1/4, 1/2)  , new THREE.Vector2( 1/4 , 1)]],
                "GREEN":[   [ new THREE.Vector2( 1/4 , 1)   , new THREE.Vector2( 1/4 , 1/2 ), new THREE.Vector2( 1/2, 1)],
                            [ new THREE.Vector2( 1/4 , 1/2 ), new THREE.Vector2( 1/2, 1/2)  , new THREE.Vector2( 1/2 , 1)]],
                "PURPLE":[  [ new THREE.Vector2( 1/2 , 1)   , new THREE.Vector2( 1/2 , 1/2 ), new THREE.Vector2( 3/4, 1)],
                            [ new THREE.Vector2( 1/2 , 1/2 ), new THREE.Vector2( 3/4, 1/2)  , new THREE.Vector2( 3/4, 1)]]}
    var params = {
        showMainAxis:true,
        size:50,
        axis:[0,0,0],
        speed:5,
        rotation:90 * Math.PI / 180,
            //  X+              X0          X-
        nodes:[ 1*2*3*5     ,   1*2*5   ,   1*2*5*7     ,//Y+   Z+
                1*2*3       ,   1*2     ,   1*2*7       ,//     Z0
                1*2*3*11    ,   1*2*11  ,   1*2*7*11    ,//     Z-

                1*3*5       ,   1*5     ,   1*5*7       ,//Y0
                1*3         ,   1       ,   1*7         ,
                1*3*11      ,   1*11    ,   1*7*11      ,

                1*3*5*13    ,   1*5*13  ,   1*5*7*13    ,//Y-
                1*3*13      ,   1*13    ,   1*7*13      ,
                1*3*11*13   ,   1*11*13 ,   1*7*11*13   ],
        perm:[]
            }

    /* ### GUI controls ### */
    var gui = undefined;
    function initGUI() {
        gui = new dat.GUI();//<--- BLACK MAGIC

        gui.add(params, 'showMainAxis').onChange(update)
        //gui.add(params, 'axis').onChange(update)

    }
    function updateGUI(theGui) {
        if (typeof(theGui)==="undefined") theGui=gui;

        // Update the GUI display based on current parameters
        // Source: http://stackoverflow.com/a/29069189
        for (var i in gui.__controllers) {
            theGui.__controllers[i].updateDisplay();
        }
        // Do recursion to update inside folders
        for (var f in gui.__folders) {
            updateGUI(theGui.__folders[f]);
        }
    }

    /* ### Keyboard ### */
    var currentlyPressedKeys = {};
    function initKeys(canvas) {
        // Make sure the canvas can receive the key events
        canvas.setAttribute('tabindex','0');
        canvas.focus();
        // Workaround: give the focus back to the canvas when clicked
        // keyboard events are not received when canvas is not focused
        canvas.addEventListener('mousedown',function(){canvas.focus()});

        // Register the keyDown and keyUp events
        canvas.addEventListener( "keydown", onKeyDown, true);
        canvas.addEventListener( "keyup",   onKeyUp, true);
    }
    // Callbacks for discrete key events
    function onKeyDown(event){
        // Uncomment this to display key presses to find the keyCodes
        //console.log(event)
        event.preventDefault();

        // Handle single key presses (for example for firing the gun)
        if (event.keyCode == 67) { // K
            console.log('Pressed key "K"')
        }
        if ("0,0,0"!=params.axis){
            //console.log("returning")
            return
        }
        if (event.key == "1") {
            x1(params.showMainAxis)
        }
        if (event.key == "2") {
            x2(params.showMainAxis)
        }
        if (event.key == "3") {
            x3(params.showMainAxis)
        }
        if (event.key == "4") {
            y1(params.showMainAxis)
        }
        if (event.key == "5") {
            y2(params.showMainAxis)
        }
        if (event.key == "6") {
            y3(params.showMainAxis)
        }
        if (event.key == "7") {
            z1(params.showMainAxis)
        }
        if (event.key == "8") {
            z2(params.showMainAxis)
        }
        if (event.key == "9") {
            z3(params.showMainAxis)
        }
        updateGUI() // Update dat.GUI display in case we changed params
        update()    // Update scene
    }
    function onKeyUp(event){}
    function degToRad(a){//THIS SHOULD BE PART OF  MATH
        return a/180*Math.PI;
    }
    //params.work=[]

    /* ### Main functions: init, update, animate, render... ### */
    function initScene(){
        // ##### 1. Create renderer and bind it to the canvas #####

        canvas = document.getElementById("canvas")
        renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        preserveDrawingBuffer: true});
        //document.body.appendChild(renderer.domElement)
        renderer.setClearColor(0xffffff)

        //renderer.setClearColor(0xffffff)


        // ##### 2. Create a scene and add objects to it #####

        scene = new THREE.Scene();

    	drawAxis(true)
        drawNodes()

        // ##### 3. Add lights to the scene #####
        var ambientLight = new THREE.AmbientLight(0x303030);
        scene.add(ambientLight)

        var pointLight = new THREE.PointLight(0xffffff)
        pointLight.position.set(150, 250, 125)
        scene.add(pointLight)

        // Add a sphere to be able to see where the point light is located
        // Not necessary for the light to work, can be disabled in the GUI
        pointLightGeo = new THREE.SphereGeometry(10, 8,4)
        pointLightMat = new THREE.MeshBasicMaterial({color:0xffffd0, wireframe:true})
        pointLightMesh = new THREE.Mesh(pointLightGeo, pointLightMat)
        pointLightMesh.position.copy(pointLight.position)
        scene.add(pointLightMesh)


        // ##### 4. Create camera #####

        camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 1, 2000);
        camera.position.set(100, 150, 150)
        camera.lookAt(new THREE.Vector3(0, 0, 0))


        // ##### 5. Add orbit controls #####
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.addEventListener('change', render); // add this only if there is no animation loop (requestAnimationFrame)
        controls.enableDamping = true;
        controls.dampingFactor = 0.10;
        controls.enableZoom = true;
        controls.enableKeys = false; // Disable keys so we can use them ourselves
        controls.rotateSpeed = 0.1;
    }
    function drawNodes(){
        var textureLoader = new THREE.TextureLoader()
        //var face = textureLoader.load("image/colorsN.png")
        var face = textureLoader.load("image/colors.png")

        var geometry = new THREE.BoxGeometry( 1, 1, 1 )
        var material = new THREE.MeshBasicMaterial( {color: 0xffffff , map:face} )

        var mesh = new THREE.Mesh(geometry , material )

        mesh.geometry.faceVertexUvs[0][1] = colors["RED"][0]
        mesh.geometry.faceVertexUvs[0][0] = colors["RED"][1]
        mesh.geometry.faceVertexUvs[0][2] = colors["YELLOW"][0]
        mesh.geometry.faceVertexUvs[0][3] = colors["YELLOW"][1]
        mesh.geometry.faceVertexUvs[0][4] = colors["WHITE"][0]
        mesh.geometry.faceVertexUvs[0][5] = colors["WHITE"][1]
        mesh.geometry.faceVertexUvs[0][6] = colors["BLUE"][0]
        mesh.geometry.faceVertexUvs[0][7] = colors["BLUE"][1]
        mesh.geometry.faceVertexUvs[0][8] = colors["GREEN"][0]
        mesh.geometry.faceVertexUvs[0][9] = colors["GREEN"][1]
        mesh.geometry.faceVertexUvs[0][10] = colors["PURPLE"][0]
        mesh.geometry.faceVertexUvs[0][11] = colors["PURPLE"][1]

        params.model = mesh
        params.model.scale.set(params.size,params.size,params.size)
        scene.add(params.model)
    }
    function drawAxis(){
        mainAxis = new THREE.AxisHelper(100);
        mainAxis.material.linewidth = 5
        scene.add(mainAxis);
    }
    function x1(forward){
        params.perm = [4,2,5,3]
        if (forward){
            params.axis=[1,0,0]
        }
        else{
            params.perm.reverse()
            params.axis=[-1,0,0]
        }
    }
    function x2(forward){
        params.perm = [4,2,5,3]
        if (forward){
            params.axis=[1,0,0]
        }
        else{
            params.perm.reverse()
            params.axis=[-1,0,0]
        }
    }
    function x3(forward){
        params.perm = [4,2,5,3]
        if (forward){
            params.axis=[1,0,0]
        }
        else{
            params.perm.reverse()
            params.axis=[-1,0,0]
        }
    }
    function y1(forward){

        if (forward){
            params.axis=[0,1,0]
        }
        else{
            params.axis=[0,-1,0]
        }
    }
    function y2(forward){

        if (forward){
            params.axis=[0,1,0]
        }
        else{
            params.axis=[0,-1,0]
        }
    }
    function y3(forward){

        if (forward){
            params.axis=[0,1,0]
        }
        else{
            params.axis=[0,-1,0]
        }
    }
    function z1(forward){

        if (forward){
            params.axis=[0,0,1]
        }
        else{
            params.axis=[0,0,-1]
        }

    }
    function z2(forward){

        if (forward){
            params.axis=[0,0,1]
        }
        else{
            params.axis=[0,0,-1]
        }
    }
    function z3(forward){

        if (forward){
            params.axis=[0,0,1]
        }
        else{
            params.axis=[0,0,-1]
        }
    }

    /*Rotation and mesh update*/

    function permute(){}
    function swapTexture(target){

        for (var i = 0 ; i < target.faceVertexUvs[0].length-1 ; i++){

            target.faceVertexUvs[0][i][0].set(target.faceVertexUvs[0][i+1][0])



            //target.faceVertexUvs[0][params.perm[i]][0].set(x , y)
            //target.faceVertexUvs[0][params.perm[i]][1].set(x , y)
            //target.faceVertexUvs[0][params.perm[i]][1].set(x , y)
            }

        target.uvsNeedUpdate = true
        //console.log("update")

    }
    function resetRotation(){
        swapTexture(params.model.geometry)
        params.model.rotation.set(0,0,0)

        params.axis=[0,0,0]
        params.rotation=90 * Math.PI / 180

    }
    function rotate(){
        params.rotation = params.rotation-params.speed*elapsed
        target = params.model
        target.rotateX(params.speed*elapsed*params.axis[0])
        target.rotateY(params.speed*elapsed*params.axis[1])
        target.rotateZ(params.speed*elapsed*params.axis[2])
    }

    /* ### Timing and main loop ### */
    var startTime = 0;
    var lastTime = 0;
    var elapsed = 0, totalElapsed = 0;
    function updateTime() {
        var timeNow = new Date().getTime() / 1000; // All expressed in seconds
        if (lastTime != 0) {
            elapsed = timeNow - lastTime;
        } else {
            startTime = timeNow;
        }
        lastTime = timeNow;
        totalElapsed = timeNow - startTime;
    }
    function update(){
        // Helpers: plane and axes
        mainAxis.visible = params.showMainAxis;//show the main axis or not
        if ("0,0,0"!=params.axis){//DARK ART OF THE HIGHEST ORDER
            if (params.rotation>0){
                rotate()
            }
            else{
                resetRotation()
            }
        }
        render()
    }
    function animate(){
        updateTime()
        update()
        render()
        requestAnimationFrame(animate);
    }
    function render(){
        renderer.render(scene, camera);
    }
    function start(){
        initGUI()
        initScene()
        initKeys(canvas)

        update()
        render()
        //z3(true)
        // Uncomment animate() if there are automatic animations in your scene
        animate()
    }
</script>

<body onload='start();'>

  <div style="float: left;">
    <canvas id="canvas" width="500" height="500"></canvas>
    <br>3d Scene
    <br>Hold Left Mouse Button and drag to orbit around the scene.
    <br>Use arrow keys to move and rotate the robot using tank controls.
    <br>Use the gui on the right to:
    <br>articulate the robot arms in one axis
    <br>turn the plane on and off
    <br>turn the plane grid on and off
    <br>turn turn the main axis on and off
    <br>turn the objects axis on and off


  </div>

</body>

</html>
